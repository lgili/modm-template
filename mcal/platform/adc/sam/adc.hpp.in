/*
 * Copyright (c) 2021, Jeff McBride
 * Copyright (c) 2022, Christopher Durand
 * Copyright (c) 2023, Luiz Carlos Gili
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
#pragma once

#include <modm/architecture/interface/adc.hpp>
#include <modm/math/algorithm/prescaler.hpp>
#include <modm/platform/clock/clockgen.hpp>
#include <modm/platform/gpio/connector.hpp>

%% if type == "afec"
%% set reg = "AFEC"
%% else
%% set reg = "ADC"
%% endif

namespace modm::platform
{

/// @ingroup modm_platform_adc
class {{type | capitalize}}{{instance}} : modm::Adc
{
	static const modm::frequency_t MaxAdcFrequency = modm::MHz({{max_frequency}});

	// Work around a name collision between 'struct modm::Adc' and 'struct Adc'
	// defined in the CMSIS headers
	static inline auto*
	Regs()
	{
		return (::{{type | capitalize}}*){{reg}}{{instance}};
	};

public:
	enum class Channel : uint8_t
	{
%% for i in range(channel_count)
		Ch{{i}} = {{i}}{% if not loop.last %},{% endif %}
%% endfor
	};

%% if target.family != "e7x/s7x/v7x"
	/** Analog settling time setting
	 *
	 * Controls how many periods of ADC clock are allowed for input to settle.
	 */
	enum class SettlingTime : uint8_t
	{
		AST3 = 0,
		AST5,
		AST9,
		AST17
	};
%% endif

public:

	/** Trigger to start conversion
	  *
	  * Set the peripheral to start the ADC conversion.
	  */
	 enum class Trigger : uint8_t
	 {
		SOFTWARE = AFEC_MR_TRGEN_DIS,
		ADTRG_AFECx   = AFEC_MR_TRGSEL_AFEC_TRIG0 | AFEC_MR_TRGEN,    /**< (AFEC_MR) AFE0_ADTRG for AFEC0 / AFE1_ADTRG for AFEC1 Position */
		TIOACH0_AFEC0 = AFEC_MR_TRGSEL_AFEC_TRIG1 | AFEC_MR_TRGEN,    /**< (AFEC_MR) TIOA Output of the Timer Counter Channel 0 for AFEC0 */
		TIOACH1_AFEC0 = AFEC_MR_TRGSEL_AFEC_TRIG2 | AFEC_MR_TRGEN,    /**< (AFEC_MR) TIOA Output of the Timer Counter Channel 1 for AFEC0 */
		TIOACH2_AFEC0 = AFEC_MR_TRGSEL_AFEC_TRIG3 | AFEC_MR_TRGEN,    /**< (AFEC_MR) TIOA Output of the Timer Counter Channel 2 for AFEC0 */
		TIOACH3_AFEC1 = AFEC_MR_TRGSEL_AFEC_TRIG1 | AFEC_MR_TRGEN,    /**< (AFEC_MR) TIOA Output of the Timer Counter Channel 3 for AFEC1 */
		TIOACH4_AFEC1 = AFEC_MR_TRGSEL_AFEC_TRIG2 | AFEC_MR_TRGEN,    /**< (AFEC_MR) TIOA Output of the Timer Counter Channel 4 for AFEC1 */
		TIOACH5_AFEC1 = AFEC_MR_TRGSEL_AFEC_TRIG3 | AFEC_MR_TRGEN,    /**< (AFEC_MR) TIOA Output of the Timer Counter Channel 5 for AFEC1 */
		PWM0LINE0_AFEC0	  = AFEC_MR_TRGSEL_AFEC_TRIG4 | AFEC_MR_TRGEN,    /**< (AFEC_MR) PWM0 event line 0 for AFEC0 */
		PWM1LINE0_AFEC1	  = AFEC_MR_TRGSEL_AFEC_TRIG4 | AFEC_MR_TRGEN,    /**< (AFEC_MR) PWM1 event line 0 for AFEC1 */
		PWM0LINE1_AFEC0	  = AFEC_MR_TRGSEL_AFEC_TRIG5 | AFEC_MR_TRGEN,    /**< (AFEC_MR) PWM0 event line 1 for AFEC0 */
		PWM1LINE1_AFEC1	  = AFEC_MR_TRGSEL_AFEC_TRIG5 | AFEC_MR_TRGEN,    /**< (AFEC_MR) PWM1 event line 1 for AFEC1 */
		FREERUN = 0xFF,
	 };

	enum class InterruptMask : uint32_t
	{
		Eoc0 = (1U << 0U),
		Eoc1 = (1U << 1U),
		Eoc2 = (1U << 2U),
		Eoc3 = (1U << 3U),
		Eoc4 = (1U << 4U),
		Eoc5 = (1U << 5U),
		Eoc6 = (1U << 6U),
		Eoc7 = (1U << 7U),
		Eoc8 = (1U << 8U),
		Eoc9 = (1U << 9U),
		Eoc10 = (1U << 10U),
		Eoc11 = (1U << 11U),
		Compe = (1U << 26U)
	};

	// start inherited documentation
	template<class Pin, class... Pins>
	static inline void
	connect()
	{
		// Pins are automatically connected to the ADC when they are enabled,
		// so all this does is set the pin mode to input.
%% if instance
%% set peripheral = type.capitalize() + "<" + instance + ">"
%% else
%% set peripheral = type.capitalize()
%% endif
		using Connector = typename Pin::template Connector<Peripherals::{{peripheral}}, Peripherals::{{peripheral}}::Ad>;
		static_assert(Connector::PinSignal::AdcChannel >= 0, "Pin cannot be used as ADC input");
		Pin::setInput();

		// Call recursively for all Pins
		if constexpr (sizeof...(Pins)) { connect<Pins...>(); }
	}

	template<class SystemClock, frequency_t frequency = MHz({{max_frequency}}), percent_t tolerance = pct(10)>
	static inline void
	initialize()
	{
		constexpr auto result = modm::Prescaler::from_function(
			SystemClock::Frequency,                 // input frequency
			frequency,                              // desired adc frequency
			0,                                      // lowest prescaler value
			255,                                    // highest prescaler value
%% if target.family == "e7x/s7x/v7x"
			[](uint32_t x) { return (x + 1); }      // transform function
%% else
			[](uint32_t x) { return 2 * (x + 1); }  // transform function
%% endif
		);
		static_assert(result.frequency <= MaxAdcFrequency,
					  "Generated ADC frequency is above maximum frequency!");
		assertBaudrateInTolerance<result.frequency, frequency, tolerance>();

		ClockGen::enable<ClockPeripheral::{{type | capitalize}}{{instance}}>();

		/* Reset and configure the AFEC module */
		Regs()->{{reg}}_CR = AFEC_CR_SWRST;

		Regs()->{{reg}}_MR =
			{{reg}}_MR_PRESCAL(result.index) |
%% if target.family == "e7x/s7x/v7x"
			// 2: recommended value according to datasheet
			{{reg}}_MR_TRANSFER(2) |
			// The datasheet states TRACKTIM should be set to 15 AFE clock cycles.
			// According to app note 44046 this is achieved with a value of 14.
			// If the datasheets guidance is followed to not change this value the
			// ADC reads wrong values half of the time.
			// Also, none of the 3 vendor HALs use the reset value of 0.
			{{reg}}_MR_TRACKTIM(15) |
			{{reg}}_MR_ONE; // reserved, must always be set
%% else
			{{reg}}_MR_TRANSFER(2);
%% endif

%% if target.family == "e7x/s7x/v7x"
		// Enable PGAs and set up biasing
		Regs()->{{reg}}_ACR = {{reg}}_ACR_PGA1EN | {{reg}}_ACR_PGA0EN |
			AFEC_ACR_IBCTL((result.frequency >= MHz(20) ? 0b11 : 0b10));

		// set 10-bit offset DACs to zero offset (value 512, mid scale)
		for (int channel = 0; channel < {{channel_count}}; ++channel) {
			Regs()->{{reg}}_CSELR = channel; // select channel of COCR register
			Regs()->{{reg}}_COCR = 512;
		}
%% endif
	}

	static inline void
	startConversion()
	{
		Regs()->{{reg}}_CR = {{reg}}_CR_START;
	}

	static inline bool
	isConversionFinished()
	{
		return Regs()->{{reg}}_ISR & {{reg}}_ISR_DRDY;
	}

	static inline uint16_t
	getValue()
	{
		return (uint16_t)(Regs()->{{reg}}_LCDR & 0xffff);
	}

	static inline uint16_t
	getChannelResult(uint8_t channel)
	{
		Regs()->{{reg}}_CSELR = (uint8_t)channel;
		return (uint16_t)(Regs()->{{reg}}_CDR);
	}

	static inline uint16_t
	readChannel(uint8_t channel)
	{
		if (!setChannel(channel)) return 0;

		startConversion();
		while (!isConversionFinished()) {}

		return getValue();
	}

	static inline bool
	setChannel(Channel channel)
	{
		return setChannel((uint8_t)channel);
	}

	static inline bool
	setChannel(uint8_t channel)
	{
		if (channel >= {{channel_count}}) return false;
		Regs()->{{reg}}_CHDR = (1u << {{channel_count}}) - 1u;
		Regs()->{{reg}}_CHER = (1 << channel);
		return true;
	}

	static inline bool
	enableChannel(uint8_t channel)
	{
		if (channel >= {{channel_count}}) return false;
		Regs()->{{reg}}_CHER = (1 << channel);
		return true;
	}

	static inline void
	enableFreeRunningMode()
	{
		Regs()->{{reg}}_MR |= {{reg}}_MR_FREERUN;
	}

	static inline void
	disableFreeRunningMode()
	{
		Regs()->{{reg}}_MR &= ~{{reg}}_MR_FREERUN;
	}

	/* Configure the user defined conversion sequence */
	static inline void
	enableUserSequence(uint32_t *channelList, uint8_t numChannel)
	{
		uint8_t channelIndex;
		Regs()->{{reg}}_SEQ1R = 0U;
		Regs()->{{reg}}_SEQ2R = 0U;
		Regs()->{{reg}}_MR |= AFEC_MR_USEQ_Msk;
		constexpr uint8_t {{reg}}_SEQ1_CHANNEL_NUM  = (8U);

		for (channelIndex = 0U; channelIndex < {{reg}}_SEQ1_CHANNEL_NUM; channelIndex++)
		{
			if (channelIndex >= numChannel)
			{
				break;
			}
			Regs()->{{reg}}_SEQ1R |= (uint32_t)channelList[channelIndex] << (channelIndex * 4U);
		}
		if (numChannel > {{reg}}_SEQ1_CHANNEL_NUM)
		{
			for (channelIndex = 0U; channelIndex < (numChannel - {{reg}}_SEQ1_CHANNEL_NUM); channelIndex++)
			{
				Regs()->{{reg}}_SEQ2R |= (uint32_t)channelList[channelIndex + {{reg}}_SEQ1_CHANNEL_NUM] << (channelIndex * 4U);
			}
		}
	}

	/**
	 * \brief Configure conversion trigger and free run mode.
	 */
	static inline void
	setTrigger(Trigger trigger)
	{
		uint32_t reg;
		reg = Regs()->{{reg}}_MR;

		if (trigger == Trigger::FREERUN) {
			reg |= {{reg}}_MR_FREERUN_ON;
		} else {
			reg &= ~({{reg}}_MR_TRGSEL_Msk | {{reg}}_MR_TRGEN | {{reg}}_MR_FREERUN_ON);
			reg |= (uint32_t)trigger;
		}

		Regs()->{{reg}}_MR |= reg;
	}

	/* Enable channel end of conversion interrupt */
	static inline void
	enableInterrupt(InterruptMask interruptMask)
	{
		Regs()->{{reg}}_IER |= (uint32_t)interruptMask;
	}

	/** Enable the NVIC IRQ for this timer channel
	 */
	static inline void
	enableInterruptVector(bool enable, uint32_t priority=1)
	{
		if(enable)
		{
			NVIC_SetPriority({{reg}}{{instance}}_IRQn, priority);
			NVIC_EnableIRQ({{reg}}{{instance}}_IRQn);
		} else {
			NVIC_DisableIRQ({{reg}}{{instance}}_IRQn);
		}
	}

	/** Reads the currently pending interrupt flags
	 *
	 * Flags are automatically cleared in hardware when they are read
	 */
	static inline uint32_t getInterruptFlags()
	{
		return Regs()->{{reg}}_ISR;
	}

	// end inherited documentation

%% if target.family != "e7x/s7x/v7x"
	/** Configure the amount of time the ADC input is allowed to settle before sampling
	 */
	static inline void
	setSettlingTime(SettlingTime time)
	{
		Regs()->{{reg}}_MR = (Regs()->{{reg}}_MR & ~{{reg}}_MR_SETTLING_Msk) | {{reg}}_MR_SETTLING((uint8_t)time);
	}
%% endif

	template<class Pin>
	static inline constexpr uint8_t
	getPinChannel()
	{
		using Connector = typename Pin::Ad::template Connector<Peripherals::{{peripheral}}, Peripherals::{{peripheral}}::Ad>;

		static_assert(Connector::PinSignal::AdcChannel >= 0, "Pin cannot be used as ADC input");
		return Connector::PinSignal::AdcChannel;
	}
};

}  // namespace modm::platform
